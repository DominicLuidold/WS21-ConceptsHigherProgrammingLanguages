\documentclass[a4paper,12pt,twoside]{scrreprt}
% Autor der Vorlage: Klaus Rheinberger, FH Vorarlberg, 2017-02-20

% Pakete:
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % Silbentrennung bei Sonderzeichen
\usepackage{graphicx} % Bilder einbinden
\usepackage{wrapfig} % Bilder positionieren
\usepackage[english]{babel} 
\usepackage{minted} % Code Highlighting/Import
\usepackage{csquotes} % Anführungszeichen und Zitieren
\usepackage[bindingoffset=8mm]{geometry} % Bindeverlust von 8mm einbeziehen
\usepackage{caption} % Abbildungslegenden
\usepackage{setspace} % Zeilenabstand
\usepackage[style=alphabetic,citestyle=alphabetic,backend=biber]{biblatex} % Literaturverweise
\usepackage[
    linktocpage=true,
    pdfauthor={Dominik Böckle & Dominic Luidold},
    pdftitle={Translating the concepts of Haskell into the object-oriented programming language Java}
]{hyperref} % Links
\usepackage{acronym} 
\usepackage{eurosym}

% Einstellungen:
\captionsetup{format=hang, justification=raggedright}
\addbibresource{Sources.bib}
\setcounter{secnumdepth}{4}
\renewcommand{\listingscaption}{Sourcecode}
 \renewcommand\listoflistingscaption{Sourcecode}

% Dokumentenbeginn
\begin{document}
\onehalfspacing % Zeilenabstand 1,5

% Titelblatt:
% \newpage\mbox{}\newpage
\pagenumbering{Roman}
\cleardoublepage % force output to a right page
\thispagestyle{empty}
\begin{titlepage}
    \begin{flushright}
    \includegraphics[width=0.4\linewidth]{Logo-A3.jpg}
    \end{flushright}
    \begin{flushleft}
    \vspace{0.5cm}
    \section*{Translating the concepts of Haskell into the object-oriented programming language Java}
    \subsection*{Written Elaboration}

    \vspace{4cm}
    Vorarlberg University of Applied Sciences\newline
    Computer Science MSc

    \vspace{0.5cm}

    Supervised by\newline
    Jonathan Thaler, Ph.D

    \vspace{0.5cm}

    Submitted by\newline
    Dominik Böckle,\newline
    Dominic Luidold\newline\newline
    Dornbirn, January 2022
    \end{flushleft}
\end{titlepage}

% Inhaltsverzeichnis:
\cleardoublepage % force output to a right page
\setcounter{tocdepth}{2}
\pdfbookmark{\contentsname}{toc}
\tableofcontents

% Abkürzungsverzeichnis:
\clearpage
\phantomsection
\addcontentsline{toc}{chapter}{List of Abbreviations}
\chapter*{List of Abbreviations}
\begin{acronym}
  \acro{ADT}{Algebraic Data Types}
  \acro{OOP}{Object-oriented programming}
\end{acronym}

\cleardoublepage
\pagenumbering{arabic}
\chapter{Introduction}
This written elaboration contains various concepts of functional programming that are covered in the lecture \enquote{Concepts of Higher Programming Languages} in the first semester Master of Science at the Vorarlberg University of Applied Sciences. The concepts and patterns covered in this course are implemented in this paper using the \ac{OOP} language Java. Each implementation is complemented by a short explanation.

In addition, a \texttt{StateMonad} is implemented in Java and an example of how to use the Monad implemnetation is provided.

\chapter{Implementation of the various concepts}
This chapter covers the implementation of eight functional programming concepts and their respective \acs{OOP} counterparts written in Java. The concepts and patterns are each accompanied by a brief explanation as well as a working Java example.

\section{Immutable Data}
\textit{Immutable Data} is a principle that states that once data has been created, it subsequently cannot be changed. In general, data and objects should only be mutable if there is a valid reason for doing so.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos]{java}{./code/ImmutableIntegerPair.java}
    \caption[Example of an immutable data structure]{Example of an immutable data structure}
    \label{code:immutable}
\end{listing}

\textit{Sourcecode \ref{code:immutable}} on page \pageref{code:immutable} shows how an immutable data structure may look. The variables \texttt{x} and \texttt{y}, which contain the data, can no longer be modified after the value has initially been set as a result of the \texttt{final} keyword. Additionally, the variables cannot be changed from outside the class as there are no setters present.

There is, however, still a possibility to make the data structure mutable: Extending the \texttt{ImmutableIntegerPair} allows one to extend the functionality of the data structure and store mutable data. To prevent this, the keyword \texttt{final} can be used again, this time at class level as opposed to variable level.

\medskip

Furthermore, there are also ways to make lists immutable when the list data type is the preferred/required way of storing data. Java itself provides a static method \texttt{Collections::unmodifiableList()} which prevents the data from being modified. However, the data type that is stored in the list must also be immutable to achieve immutability.

\section{Type Variables}
As far as the concept of \textit{Type Variables} is concerned, Java - being a strongly typed programming language - enables the typing of variables and the enforcement of a certain type throughout the programme flow in various ways:

\begin{itemize}
    \item Each variable has to have an accompanying data type when getting declared, e.g. \texttt{int x = 1;}
    \item Java natively supports Generics (as can be seen in \textit{Sourcecode \ref{code:ADT}} on page \pageref{code:ADT}) which allows types to be enforced based on the specific use case at compile time. Constructs such as \texttt{<? extends Integer>} additionally allow the restriction of which types are \enquote{allowed}.
    \item Checking types at run time is possible using \texttt{instanceof} when there are several types possible at one point in a time, for example when having a common interface and different classes inheriting that interface.
\end{itemize}

\clearpage

\section{Higher-Order Functions}
A \textit{Higher-Order Function} is a function that either takes a function as an argument or has a function as a return value. Implementing this concept has been possible since Java 8 - an example for that is shown in \textit{Sourcode \ref{code:higherordered}} on page \pageref{code:higherordered}. The method \texttt{camelize} capitalises the first character of a string and returns the required method/function calls when called. This method also makes use of \textit{Lambdas}, which is explained in more detail in a subsequent chapter.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos,breaklines,breakanywhere]{java}{./code/HigherOrderFunctions.java}
    \caption[Example of a Higher-Order Function in Java 8]{Example of a Higher-Order Function in Java 8}
    \label{code:higherordered}
\end{listing}

\clearpage

\section{Lambda Expressions}
The method \texttt{listLambdas} in \textit{Sourcode \ref{code:Lambda}} on page \ref{code:Lambda} increments the \texttt{Integer} values stored in a \texttt{List} by one. This is achieved by the rather short code fragment \texttt{map(x -> ++x)}.

The same functionality can be achieved be creating an anonymous \texttt{Function} instance within the \texttt{map} method (not shown in this example), which has been the recommended and only way until to Java 8 to implement such functionality. However, Lambda Expressions have the advantage of code that is usually more readable and requires less boilerplate code.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos]{java}{./code/LambdaExpressions.java}
    \caption[Example of a Lambda Expression]{Example of a Lambda Expression}
    \label{code:Lambda}
\end{listing}

\clearpage

\section{Currying}
\textit{Currying} is the conversion of a function with multiple arguments into a sequence of functions with one argument each. \textit{Sourcecode \ref{code:Currying}} on page \pageref{code:Currying} is inspired by \cite{Robertson_currying_2018} in which multiplication was performed by currying. This is emulated with the function \texttt{multCurry} where the multiplications can be concatenated.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos,breaklines,breakanywhere]{java}{./code/Currying.java}
    \caption[Example of Currying]{Example of Currying}
    \label{code:Currying}
\end{listing}

\clearpage

\section{Function Composition and Streaming}

\subsection{Function Composition}
\textit{Function Composition} is applying the pattern of combining multiple separate functions into a single function. The output of the first function is then used as input for the second function and so on. To be able to demonstrate this in an example, \textit{Sourcecode \ref{code:Compose}} on page \pageref{code:Compose} containts the functions \texttt{doubleInt} and \texttt{substractOne} - both based on the use of Lambda Expressions. 

An important part of Function Composition is that order matters. While using  \texttt{compose(<fn>)} results in the supplied function (\texttt{substractOne}) being executed before the initial function (\texttt{doubleInt}), using \texttt{andThen(<fn>)} has the opposite result.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos,breaklines,breakanywhere]{java}{./code/FunctionComposition.java}
    \caption[Example of Function Composition and that order matters]{Example of Function Composition and that order matters}
    \label{code:Compose}
\end{listing}

\clearpage

\subsection{Streaming}
A \textit{Stream} or \textit{Streaming} represents a sequence of objects that are accessed in sequential order. One of the best known and most frequently used Streams in Java is probably the \texttt{FileStream}, which is used to read files and file contents. \textit{Sourcecode \ref{code:Streaming}} on page \pageref{code:Streaming} shows this in a small, but only theoretical example.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos,breaklines]{java}{./code/Streaming.java}
    \caption[Example of Streaming]{Example of Streaming.}
    \label{code:Streaming}
\end{listing}

\clearpage

\section{Algebraic Data Types}
An \ac{ADT} consists of several variants or flavors, similar to a Java enum, but the different flavors can have different properties or methods.

To summarize again what we expect from an \ac{ADT}:
The expressions have different numbers and types of properties and methods.
At compile time it is checked that all expressions are also considered.

Unfortunately, Java does not support ADT from scratch, so we have to implement this ourselves. For this, as described in \cite{MAINIERO_algebraic_2020}, the design patterns Visitor and Sealed Class are helpful. In Java 15 the sealed class should be automatically integrated but in Sorce code it was still implemented manually without the sealed keyword.

\emph{Sourcecode \ref{code:ADT}} shows a Java implementation of the Alive or Date State from the lecture notes \footnote{ lecture notes: https://homepages.fhv.at/thjo/lecturenotes/concepts/declaring-types.html\#algebraic-data-types-1 visited on 2022/01/06}.
\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos]{java}{./code/ADT.java}
    \caption[Example for a \ac{ADT}]{Dead or Alive Example to demonstrate \ac{ADT}.}
    \label{code:ADT}
\end{listing}
\clearpage


\section{Pure and Impure Side Effects}
Pure: Side effects are effects which are influenced by the Pure calculation and are always deterministic because they do not communicate with the outside world. \emph{Sourcecode \ref{code:Effects}} shows the change of the "State" in the method Pure.
\newline
Impure: are all effects which interact with the outside world this is declared in \emph{Sourcecode \ref{code:Effects}} with the method Impure which waits for a user action
\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize,linenos]{java}{./code/SideEffects.java}
    \caption[Example for Side Effects]{Example for Side Effects.}
    \label{code:Effects}
\end{listing}
\clearpage

% Literaturverzeichnis:
\clearpage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

\end{document}
